---
title: "Shell gets a settings modal; purefoy gets a transcription pipeline; node-template renames itself core"
date: 2026-03-01
tags: ["shell", "module-federation", "purefoy", "node-template", "settings-modal", "frame-os"]
summary: "Shell claims settings chrome across all sub-apps via Module Federation; purefoy ships faster-whisper transcription; node-template becomes core."
---

59 commits across six repos today, and the through-line is ownership boundaries. Shell took ownership of settings modal chrome across all three sub-apps in one coordinated PR set. purefoy crossed from scraper to pipeline. node-template dropped the 'template' and became core. Each of these is the same move: deciding what belongs where and making it explicit.

## What shipped

**Shell #7 + sub-app settings panels (merged):** Shell now owns the modal chrome — `<Modal>` wrapper, title bar, close mechanics, `<Suspense>` fallback, and a class-based `ErrorBoundary` per app type. Each sub-app exposes a bare `SettingsPanel` component via Module Federation `'./Settings'` and nothing else. cv-builder #102, BlogEngine #21, and TripPlanner #12 all merged the same day, each adding a `SettingsPanel.tsx` that renders inside shell's owned chrome. Three review iterations on shell #7 landed in a single session: z-index `!important` fix, `showSettings` DRY refactor, ErrorBoundary `componentStack` logging, always-mounted modal pattern with EB reset on close.

The always-mounted modal pattern (rather than conditional render) was a deliberate choice to avoid EB state loss on remount. When the modal closes, the ErrorBoundary resets — not the modal DOM. This is the kind of nuance that only surfaces after you've written the naive version and watched it break.

**Shell #4 merged — Carbon polish:** Breadcrumb navigation with Carbon motion tokens, home button with guard against redundant navigation, animated header, MF app loading state, and a full CSS regression cleanup from the `APP_CONFIG` refactor that preceded it. `APP_CONFIG` itself (`bffbfab`) became the single source of truth for app metadata, eliminating the `APP_LABELS` duplication caught in review. One object, one import, no divergence path.

> **Why Carbon?** Carbon is IBM's design system and carries real opinions about component structure — it's not an obvious default for a browser-native shell. The choice was pragmatic: Carbon's motion tokens and breadcrumb primitives matched the navigation interaction model already specced, and the accessibility baseline is production-grade out of the box. A full evaluation against alternatives isn't documented in an ADR yet; that gap is acknowledged.

**purefoy #3 merged — transcription pipeline:** `scripts/tools/` now contains a faster-whisper large-v3 runner with int8 CPU or float16 GPU modes. Outputs `transcript.json`, `transcript.txt`, `transcript_segments.jsonl`, chapters, and embeddings. AWS EC2 batch runner handles the heavy lifting. ADR-004 documents the decision. CI format check fixed with `ruff` on the `deakins_forums/` directory.

> **Why EC2 batch rather than a managed service?** faster-whisper large-v3 at float16 GPU quality doesn't fit in a Lambda or Fargate task without significant cost overhead — the model size and memory requirements push you off serverless. ADR-004 documents this reasoning. An honest gap: the per-transcript cost figure and the Fargate comparison aren't written down yet. "Significant cost overhead" is not a number, and it should be before this decision is considered closed.

**node-template #6 merged — core rename + `/frame-dev` skill:** `node-template` is now `core`. `/frame-dev` skill + `scripts/frame-dev.sh` starts, stops, and reports status across all Frame OS dev servers in one command. ADR-0009 documents the dual-mode architecture (shell on pnpm at `:4000/:4001`, sub-apps on Vite). Decisions directory migrated to nested `decisions/` structure for domain isolation.

**node-template #9 merged — CoreReader planning docs:** ADR-0010 specifies the CoreReader metadata dashboard — a self-referential Frame OS status panel that reads cluster state and surfaces it inside Frame itself. `frame-os-context` updated with open questions resolved. Webpack → Vite correction applied to core-reader planning docs.

> **Suggested actions**
> - `/adr` — document the shell chrome ownership contract (modal, Suspense, ErrorBoundary) as a reusable pattern for the command bar surface

## The decisions

**Shell owns the modal chrome — sub-apps own zero chrome.** This is the core architectural bet in shell #7. The previous state — each app managing its own modal, its own z-index, its own close mechanics — was fragmented UX and impossible to reason about when a sub-app pod was down. The new contract is explicit: shell provides `<Modal>`, `<Suspense>`, and `ErrorBoundary`; sub-apps expose a single `'./Settings'` MF entry point that renders a bare panel with no surrounding chrome.

The `SettingsPanel` components that shipped today are deliberately thin — cv-builder's is a static info panel, BlogEngine's is a self-contained form, TripPlanner's is a coming-soon stub. **The stub is fine. The boundary is what matters.** An incomplete implementation inside a correct boundary is better than a complete implementation inside a wrong one.

Settings is the first non-navigation surface the shell has claimed. Before today, shell owned navigation chrome. Now it owns navigation chrome *and* settings chrome. The pattern established here — shell chrome, MF-loaded panel, EB isolation — is the same pattern the command bar will use. That's the milestone.

> **What enforces this contract?** Right now: the ADR and code review. There is no CI check or Federation config constraint preventing a future sub-app from shipping its own modal wrapper and quietly violating the boundary. That enforcement gap should be closed before the pattern is replicated for the command bar surface. A linting rule or Federation-layer constraint is the right next step.

**`APP_CONFIG` as single source of truth** eliminated a class of drift where `APP_LABELS` and the config object could disagree. This is the same principle as ADR-0009's dual-mode architecture: reduce the number of places a fact lives to one. The `APP_CONFIG` registry is also the foundation Phase 2 (Figma MCP) needs — a canonical app registry to drive design tokens from.

**purefoy's connection to Frame OS:** purefoy is a separate project but not an unrelated one. The faster-whisper transcription pipeline produces speaker-level transcript segments and embeddings that will feed the knowledge base ShellAgent queries. The ownership boundary decision in purefoy — batch runner on EC2, structured output format, ADR documenting the tradeoffs — is the same discipline applied to a different layer of the stack. The explicit connection to shell is: before ShellAgent can answer questions about recorded content, that content has to exist in a queryable form. purefoy is building that form.

**Assistant-centric architecture — what it means concretely:** The project is building toward a shell where ShellAgent orchestrates sub-apps via natural language. "Assistant-centric" (the first of four pillars threading every architecture decision here) means the shell is designed from the start around what an agent needs to control, not what a human clicks. Shell owning the settings chrome is the infrastructure form of that principle: before ShellAgent can invoke a settings action across any sub-app, the shell has to own the surface. The wire isn't fully connected yet — ShellAgent calling a specific MF-loaded settings action via tool call is the next step, and it isn't built. That gap is real and acknowledged. What shipped today is the prerequisite surface.

The pattern is analogous to how Roblox's runtime owns persistent session chrome while creators own content within it — the platform layer controls the surfaces, the hosted experiences control their content. Frame is applying the same model at the AI orchestration layer: shell owns chrome, agents control shell, sub-apps stay content.

> **Suggested actions**
> - `/adr` — write ADR-0011 covering the `'./Settings'` MF entry point convention and always-mounted modal + EB reset pattern before shell #6 leaves draft
> - `/investigate` — evaluate whether the `APP_CONFIG` registry can drive Phase 2 Figma MCP token generation directly
> - `/investigate` — document the per-transcript EC2 cost and Fargate comparison in ADR-004 before closing the infrastructure decision

## Roadmap pulse

**Phase 1 (shell extraction) — accelerating.** The settings modal merge is the most significant cross-repo coordination to land since the initial MF remote work. Shell now owns two surfaces: navigation chrome and settings chrome. Frame OS is running locally at `:4000/:4001`; there is no public URL yet. The current user-facing state is a shell host with three sub-apps loadable via MF, breadcrumb navigation, and a working settings modal for each app. Production deployment story is not yet defined — that gap is real.

**In-flight PRs:**
- [shell] #6 [DRAFT] — `feat: migrate sub-app settings modals into the shell (ADR-0011)` opened today. Draft status means the decision record is being written before implementation continues — correct order of operations.
- [TripPlanner] #11 — full Phase B feature set (itineraries UI, MF remote, API tools). Still open from 2026-02-27. The MF remote work in #12 merging today makes #11 closer to ready — the Federation plumbing is proven.
- [TripPlanner] #9 — intelligent trip import prototype. Open since December. Blocked behind #11.
- [MrPlug] #22 — GitHub integration, MCP code deleted. Open since December. MrPlug rebuild as Frame dev companion is roadmap Phase 5; this PR is a prerequisite cleanup.

**CoreReader (node-template issue #8 closed):** ADR-0010 merged with open questions resolved. Implementation not started. This is the self-referential Frame OS metadata dashboard — it reads cluster state and surfaces it inside Frame itself.

**shell issue #5** (Frame-wide Redux store strategy) remains open. The settings modal work deliberately avoided touching store composition — `showSettings` state lives in the shell store, sub-app panel state is local. The full cross-app store architecture question is deferred. The forcing function that closes it: the first cross-app state dependency that can't be resolved with local state. That hasn't been hit yet, but the command bar work will likely hit it.

> **Suggested actions**
> - `/pr-review` — do a focused review pass on TripPlanner #11's MF remote integration section now that #12 has proven the Federation plumbing against the shell host
> - `/roadmap` — set a concrete milestone for CoreReader implementation now that ADR-0010 is resolved and issue #8 is closed
> - `/adr` — add CI enforcement mechanism for the shell chrome ownership contract to ADR-0011

## What's next

**Promote shell #6 from draft to ready.** ADR-0011 needs to capture what shell #7 established: the chrome ownership contract, the `'./Settings'` MF entry point convention, the always-mounted modal pattern, and the ErrorBoundary reset behavior. It should also specify the enforcement mechanism — linting rule or Federation constraint — that makes the contract durable. Once ADR-0011 is written and the draft lifts, the settings modal work is fully documented and the pattern is repeatable for the command bar surface.

**TripPlanner #11 review pass.** With #12 merged and the Federation plumbing proven against the shell host, #11's MF remote integration section should be reviewable in isolation from the itineraries UI work.

**Close the EC2 cost gap in ADR-004.** The per-transcript cost figure and the Fargate comparison belong in the decision record. Writing "significant cost overhead" without a number is an incomplete decision.

> **Suggested actions**
> - `/adr` — promote shell #6 from draft by completing ADR-0011 with chrome ownership contract, MF convention, EB reset pattern, and enforcement mechanism
> - `/adr` — add per-transcript cost figures to ADR-004 to close the infrastructure decision

---

*Generated by [daily-logger](https://github.com/ojfbot/daily-logger) — part of the ojfbot self-documenting development system.*
