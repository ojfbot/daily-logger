---
title: "daily-logger gets deterministic output, cv-builder becomes a Federation remote, and node-template ships two new skills"
date: 2026-02-28
tags: ["daily-logger", "module-federation", "cv-builder", "node-template", "blogengine", "structured-output"]
summary: "Structured JSON output locks daily-logger article shape; cv-builder's Dashboard loads into the shell host at runtime for the first time."
---

Today's work is a study in closing the loop on things that were almost right. daily-logger's article generation was non-deterministic because Claude ignored freeform formatting instructions — the fix was to stop asking nicely and enforce structure at the schema level. cv-builder's Module Federation setup had made it through two PRs worth of review with shared singleton config still wrong. And node-template added two skills that address a real failure mode: agents generating specs that nobody fact-checks before scaffolding runs.

## What shipped

**daily-logger — PRs #10, #11, #12, #14 merged:**

PR #14 (`feat(generate): deterministic article structure`) is the biggest structural change. Claude was ignoring freeform instructions to include `> **Suggested actions**` blockquotes — the section just didn't appear. The fix moved away from freeform instructions entirely: the prompt now requests structured JSON output and an `assembleBody()` function assembles the final markdown from typed fields. The shape of the article is now a schema contract, not a hope. If a section is missing, the error is structural, not invisible.

PR #11 added `getOpenPRs()` to the context collector — open PRs now surface in the user prompt as `## Open PRs — in-flight work` with opened date and draft flag, so Claude can't ignore in-flight work. PR #12 fixed a CI ordering bug: `pnpm test` was running before `pnpm install`, producing `vitest: not found`. PR #10 bundled three fixes: Jekyll symlink crash (dangling `domain-knowledge/` symlinks caused `realpath()` to fail before the exclude list ran), PR body tag formatting, and the action items section.

Note: the structured JSON output contract for daily-logger does not yet have an ADR. That's undocumented technical debt — the schema is load-bearing and should be versioned formally. The "Suggested actions" blockquote below flags it, but the ADR should have shipped with the decision.

**cv-builder — PRs #98, #100 merged:**

PR #98 configured `browser-app` as a Module Federation remote — `@originjs/vite-plugin-federation ^1.3.5` added, `./Dashboard` exposed. This is the first time cv-builder's Dashboard can load into the shell host at runtime. Frame is now real as a shared AI app shell, not just a collection of repos. The plumbing is there; what the user sees when that Dashboard loads into the shell is not yet designed — the visual layer hasn't caught up, and that's the next forcing function, not a Phase 9 problem.

PR #100 fixed two things that had slipped through two rounds of review: the `shared` field was using string shorthand instead of the object form required for singleton enforcement. String shorthand silently skips singleton enforcement — multiple React instances load, the Redux store gets duplicated, the shell and remote are in separate state universes. The fix is three lines (`singleton: true`, `requiredVersion` pulled dynamically from `package.json`), but the lesson is that plugin defaults optimized for simple cases are wrong for multi-app architectures.

How did this survive two PR reviews? Honestly: it's the kind of misconfiguration that produces no immediate error — the app renders, state appears to work, and the duplication only surfaces under specific cross-boundary interactions. That's not an excuse for missing it; it's the argument for a config lint rule that catches string shorthand in `shared` fields across all Frame vite configs. That lint rule doesn't exist yet — flagged as `TD-001` in the PR, not yet implemented.

PR #100 also renamed the CORS env var to `VITE_SHELL_ORIGIN` for clarity and added a pre-commit lockfile drift guard after a lockfile desync caused a CI cascade. The automatic blog-post-proposer on PRs was also disabled — it was generating noise, not signal.

**`GET /api/tools` threat model:** The endpoint is static JSON, no auth, no rate limiting. Frame is live at [frame.jim.software](http://frame.jim.software) (GitHub Pages deployment of `/shell` via CNAME), so "internal only" is not the right framing — this endpoint is reachable from the public web. The "discovery only" design is intentional for now, but the lack of auth should be treated as a known exposure, not an assumption of private context. If the payload ever includes capability details that reveal exploitable API surface, rate limiting and auth become non-optional.

**node-template — PR #5 merged:**

Two new skills shipped: `/spec-review` fact-checks agent-generated specs before scaffolding runs. `/skill-create` captures session workflows as reusable skills, closing the loop on institutional knowledge that previously lived only in chat history. ADR-0006 (GraphQL federation) was added — this documents the decision to use GraphQL federation for inter-service data composition in the Frame backend, though no app has begun implementation yet. The earned badge threshold was also updated.

**BlogEngine — PR #19 merged:**

`GET /api/tools` capability manifest endpoint added to `packages/api`. Static JSON, no auth, no rate limiting — discovery only. TripPlanner has the same endpoint open in PR #11 (in-flight), and ADR-0007 in node-template formalizes the contract across all Frame sub-apps.

**purefoy:** Git data policy established, `library/` data untracked, curation scripts added, schema examples updated to v2.

> **Suggested actions**
> - `/adr` — document the structured JSON output contract for daily-logger as an ADR; the schema is load-bearing and currently undocumented
> - `/techdebt` — implement a config lint rule catching `shared` string shorthand across all Frame vite configs; `TD-001` is flagged but not yet enforced

## The decisions

**Structured output as a reliability primitive (Pillar 2 — Tooling for iteration):**

The decision to move daily-logger's article generation to structured JSON output is the most consequential change today. The previous approach — freeform prompt instructions specifying the desired markdown format — produced articles that looked correct most of the time but silently dropped sections when Claude's attention went elsewhere. This is a known failure mode with instruction-following: the model optimizes for coherent output, not schema compliance.

The new approach treats the article as a typed data structure. Claude returns JSON with required keys (`whatShipped`, `theDecisions`, `roadmapPulse`, `whatsNext`, `actions`). `assembleBody()` assembles the document from those fields. If a section is missing, the error is structural, not invisible. This is the same discipline applied to agent tool calls in cv-builder — you don't ask an agent to "remember" to call a tool, you define the tool call as the only valid response shape. Prompt versioning and schema contracts are first-class design artifacts, not afterthoughts.

**`shared` object form vs. string shorthand in Module Federation:**

`@originjs/vite-plugin-federation` accepts both string shorthand and object form for the `shared` field, but only the object form supports `singleton: true` and dynamic `requiredVersion`. String shorthand silently skips singleton enforcement. Explicit object form, `requiredVersion` pulled from `package.json` at build time, singleton enforced: these are the correct defaults for Frame. A lint rule enforcing this across all app configs is the repeatable process that replaces "we noticed it on a follow-up pass."

**`/spec-review` as a trust boundary:**

Adding `/spec-review` to node-template acknowledges something real: when an agent generates a spec and another agent scaffolds from it, there's no human checkpoint in the loop unless you build one explicitly. The failure cost is concrete — a scaffold executing against a hallucinated spec produces a file tree and module structure that has to be manually unwound. That's not a catastrophic failure, but it's the kind of invisible error that compounds: downstream agents treat the scaffolded structure as ground truth, and the hallucination propagates. `/spec-review` is the checkpoint — a fact-check pass before scaffolding runs. High-impact actions require a summary and confirmation before firing.

> **Suggested actions**
> - `/adr` — write the Redux store composition ADR for [shell] #5 before any code touches cross-boundary state in the Module Federation setup
> - `/techdebt` — audit remaining `shared` string shorthand usages across all Frame app vite configs and convert to explicit object form

## Roadmap pulse

The phase map is a living artifact; a full summary isn't reproduced here, but the active phases are:
- **Phase 1 (shell extraction):** extracting the shell host into a standalone app that loads sub-apps as Federation remotes
- **Phase 6 (visual regression):** automated canvas diffing for cv-builder UI changes
- **Phase 9 (publishing pipeline):** daily-logger → BlogEngine → published article

These run in parallel because they have different dependencies, not because there's no sequencing logic. Phase 1 is the forcing function for Phase 9.

**Phase 1 (shell extraction):** [shell] #4 — light mode token system and Carbon hardcoded fallback removal — is open and in review. [shell] #5 (opened today) captures the next hard problem: Frame-wide Redux store strategy and sub-app store isolation. Once cv-builder's Dashboard loads into the shell host at runtime, the two Redux stores need a defined composition contract. Which store owns navigation state, how does the remote access shared state without importing the host's store directly, where does the Redux Provider boundary sit — these are ADR-level questions that need answers before the code touches them.

The visual design of what the shell looks like when cv-builder's Dashboard loads into it at runtime has not been designed. There is no Figma file referenced, no described UI state, no layout or typography decision on record. That's the build running ahead of the design — and it's the gap that will hurt when the demo needs to land in 30 seconds.

**Phase 6 (visual regression):** cv-builder run #130 canvas updated automatically by CI. Issues #94 (run-history + diff timeline) and #90 (interactive canvas viewer) are both closed. The visual regression loop is at ~70% — the remaining gap is the diff timeline between runs.

**Phase 9 (daily-logger → BlogEngine publishing):** The daily-logger pipeline is now stable enough to think seriously about Phase 9. Structured output, open PR sweeping, and the assembler pattern are the foundation.

**Capability manifest rollout:** [TripPlanner] #11 (`GET /api/tools`, ADR-0007) is open. [node-template] #6 (ADR-0007 formal spec + repo inventory correction) is open. BlogEngine's endpoint merged today (PR #19). ADR-0007 needs to land before a third app implements a drift.

**purefoy:** [purefoy] #2 (Frame backbone integration — CI/CD, ADRs, code quality, tests) is open, opened today. This brings purefoy into alignment with the rest of the org backbone.

**Frame infrastructure cost:** The shell is live at [frame.jim.software](http://frame.jim.software) — a GitHub Pages deployment of `/shell` behind a CNAME record. Sub-apps (cv-builder, BlogEngine, TripPlanner) are not yet deployed as Federation remotes against that host; they run locally. The deployment surface is real but partial. The relevant cost threshold is when cv-builder's Dashboard loads into the live shell host — that's when bundle sizes and CDN egress become trackable numbers.

**Older in-flight work:** [TripPlanner] #9 (Intelligent Trip Import, opened 2025-12-15) and [MrPlug] #22 (GitHub integration, MCP code deleted, opened 2025-12-11) remain open. Both predate the current active sprint and are not blocking Phase 1 or Phase 6 progress.

> **Suggested actions**
> - `/pr-review` — review [node-template] #6 (ADR-0007) so TripPlanner #11 and BlogEngine's endpoint have a ratified contract to implement against
> - `/roadmap` — update Phase 6 progress to reflect issues #90 and #94 closed; capture what the diff timeline would take to complete

## What's next

**Design the shell moment.** cv-builder's Dashboard loading into the shell host at runtime is the first time Frame is real as a shared AI app shell. That moment is currently undesigned — no layout, no transition, no session model surfaced to the user. This is the demo's potential "one moment." It needs to be designed before [shell] #5 goes further, not after.

**[shell] #5 — Redux store composition contract:** Write the ADR before the code. Once cv-builder's Dashboard loads into the shell host, you need a defined answer to store ownership, cross-boundary state access, and Provider boundary placement. This is the decision that makes or breaks the Module Federation integration at the application layer.

**[node-template] #6 merge:** ADR-0007 is the contract that makes the `GET /api/tools` rollout coherent across Frame apps. TripPlanner #11 and BlogEngine's endpoint are both already implementing it — the ADR should land before a third app implements a drift.

**Config lint rule for `shared` object form:** `TD-001` is flagged but not enforced. Until a lint rule exists, the singleton misconfiguration class stays open across every Frame app that adds a new vite config.

> **Suggested actions**
> - `/adr` — draft the Frame-wide Redux store strategy decision captured in [shell] #5 before Module Federation remote integration proceeds further
> - `/adr` — document the structured JSON output schema for daily-logger before the schema drifts from the prompt

---

*Generated by [daily-logger](https://github.com/ojfbot/daily-logger) — part of the ojfbot self-documenting development system.*
