---
title: "Module Federation lands in cv-builder, GET /api/tools becomes a Frame-wide contract, and the shell Redux question opens"
date: 2026-02-28
tags: ["module-federation", "cv-builder", "capability-manifest", "daily-logger", "blogengine", "node-template"]
summary: "cv-builder is now a loadable federation remote; GET /api/tools graduates from BlogEngine one-off to ADR-backed contract already spreading to TripPlanner."
---

30 commits across six repos. The through-line is integration: cv-builder wired itself into the shell's federation graph, daily-logger learned to surface in-flight decisions alongside merged work, and `GET /api/tools` went from a BlogEngine one-off to an ADR-backed contract that TripPlanner is already implementing.

The most concrete threshold crossed today: TripPlanner implementing ADR-0007 means a contract that BlogEngine invented is now adopted by a second app. That's when Frame stops being a collection of apps and starts behaving like a platform. That's the lede.

## What shipped

**cv-builder — Module Federation remote (PRs #98 + #100, both merged):** PR #98 added `@originjs/vite-plugin-federation` to `browser-app` and exposed `./Dashboard` as a federation remote so the shell host can load it at runtime. PR #100 addressed review feedback: shared dependencies moved to object form with `singleton: true` and `requiredVersion` computed dynamically from `package.json` rather than hardcoded, the CORS env var renamed from `SHELL_URL` to `VITE_SHELL_ORIGIN` for consistency, and the blog-post-proposer workflow disabled on PRs where it was generating noise rather than signal.

A lockfile drift guard landed as `TD-001`: a pre-commit hook that blocks commits when `pnpm-lock.yaml` is out of sync with `package.json`. Three CI failures this past week traced back to lockfile drift. The guard moves failure from CI (expensive, slow feedback) to local (cheap, fast feedback). It doesn't fix the underlying discipline problem, but it's the right direction for a solo developer running five active repos.

**On the shell host:** cv-builder is now a loadable remote, but the shell host repo itself — the Vite app that declares `remotes: { cvBuilder: '...' }` and mounts the federation graph — is not yet standing. `browser-app` is a module sitting ready to be loaded; there is no live URL where you can see it mounted. That is the actual Phase 1 blocker, distinct from (and more fundamental than) the Redux composition question below.

**daily-logger — unit tests + open PR sweeping (PRs #11 + #12):** The collector now fetches open PRs (top 15 per repo) alongside merged work. What's merged tells you what finished; what's open tells you what's being decided right now. PR #12 fixed a CI ordering bug where `pnpm test` ran before `pnpm install`, producing `vitest: not found` on every run. Tests for `collect-context` and `generate-article` now exist and pass in the correct order.

**BlogEngine — `GET /api/tools` (PR #19, merged):** Adds a public capability manifest endpoint to `packages/api`. The response shape is static JSON, no auth, no rate limiting — discovery-only by design. The payload:

```json
{
  "service": "blogengine",
  "version": "0.4.1",
  "capabilities": [
    "article.create",
    "article.list",
    "article.publish",
    "tag.list"
  ]
}
```

`capabilities` is currently a flat array of dot-namespaced action strings — intentionally dumb. The contract needs to stabilize across apps before anything queries it dynamically. TripPlanner is implementing this same shape in PR #11 (open). Once three apps expose it, we have enough surface to write the first ShellAgent discovery query.

**node-template — two new skills (PR #5):** `/skill-create` captures session workflows as reusable skills. `/spec-review` fact-checks agent-generated specs before scaffolding runs. ADR-0006 documents the GraphQL federation decision — the topology is hub-and-spoke: node-template owns the supergraph schema, individual Frame apps (BlogEngine, TripPlanner, cv-builder) contribute subgraphs. Which repos own which subgraphs is tracked in the node-template ADR index. Phase 0 is marked complete; the gate was: all ADRs through 0006 accepted, `/skill-create` and `/spec-review` operational, `frame-os-context` updated. No external validator — but the criteria were written before the work started, which is the closest available substitute.

**purefoy — git data policy + schema v2:** The `library/` data directory is now untracked. Schema examples updated to v2 with article schemas added. PR #2 (open) brings purefoy into the Frame OS backbone with CI/CD, ADRs, and code quality gates.

## The decisions

**`requiredVersion` dynamic vs. hardcoded:** The PR #98 review called out hardcoded version strings in the federation shared config. PR #100 reads the version from `package.json` at build time. This matters because federation version mismatches are silent at dev time and explosive in production — a host loading a remote that declares the wrong React version will either double-bundle React or throw at runtime. Dynamic resolution makes the lockfile the single source of truth.

**`GET /api/tools` as a Frame contract:** What started as a BlogEngine endpoint is now ADR-0007 in node-template, and TripPlanner is implementing it. The manifest gives the ShellAgent something to query when deciding what actions are available in the current app context. Shipping it as a dumb static endpoint first is deliberate: the contract shape — `service`, `version`, `capabilities` — needs to stabilize before dynamic querying starts. The `capabilities` array is flat action strings for now. Typed intent schemas are a later iteration.

**Shell Redux store strategy (issue #5, opened today):** How does the shell store compose with sub-app stores when each app is a federation remote with its own Redux instance? The risk is the double-Provider problem — two React-Redux contexts fighting over the same component tree. This is the same class of problem addressed for BlogEngine's store isolation in PR #98, but at the shell level it's more complex because the host doesn't know at build time what remotes will be loaded.

This should be an ADR, not an issue. The failure mode is documented, the prior art (BlogEngine PR #98 store isolation) exists, and the decision space is bounded. An ADR draft before any implementation is the call here — issue #5 is the right place to track it but not the right artifact to resolve it.

**Infrastructure and cost:** All six repos currently run CI on GitHub Actions free tier. `GET /api/tools` endpoints are deployed on Vercel free tier alongside their respective apps. No cost pressure at current scale; the relevant threshold is when the shell host goes live and starts loading multiple federation remotes — bundle sizes and cold-start latency become the first real constraints at that point. No target production date is set yet.

**ADR index:** ADRs currently live in two repos — node-template (ADR-0001 through ADR-0007, with 0008 forthcoming) and cv-builder (TD-001). There is no cross-repo index yet. That's a real gap: if ADR discipline is a genuine architectural strength here, the index should be a first-class artifact. A single linked table — ADR ID, repo, title, status (proposed / accepted / superseded) — would make the decision history legible to anyone reading the codebase, not just the author. This is flagged as a concrete next step.

## Roadmap pulse

**Phase 1 (shell extraction):** cv-builder is now a loadable federation remote. The shell host app — the repo that mounts remotes — does not yet exist. That is the real Phase 1 blocker, ahead of the Redux composition question. Shell light mode token PR (#4, open) is Carbon polish; the visual design layer is intentionally thin at this stage. The token PR is config, not a design system. The design system gets real when the shell host exists and there's a surface to apply tokens to.

**Phase 3 (ShellAgent / capability manifest):** ADR-0007 and the `GET /api/tools` rollout to BlogEngine and TripPlanner is direct Phase 3 infrastructure. Two apps expose the capability surface; TripPlanner in-flight. Once three apps are live, the first ShellAgent discovery query — even a hardcoded prototype that hits all three endpoints and merges the results — is worth building to validate the contract.

**Phase 6 (visual regression):** cv-builder issue #94 (run-history diff timeline) is open. The canvas updated with run #130 screenshots today — the pipeline is running — but the diff timeline work hasn't started. This is the remaining 30% of Phase 6.

**Phase 9 (daily-logger → BlogEngine):** Open PR sweeping makes the prompt richer. Articles are still committed to the daily-logger repo, not published through BlogEngine's agent graph. That gap is the next concrete Phase 9 work.

## What's next

Three things in priority order:

**1. ADR-0008 for shell Redux composition.** Issue #5 is open; the ADR is not drafted. The double-Provider failure mode is cheap to think through and expensive to refactor. This needs to be resolved on paper before any code in the shell host touches a Redux `Provider`. BlogEngine's store isolation approach from PR #98 is the prior art section.

**2. cv-builder minification (issue #99).** `@originjs/vite-plugin-federation` production bundle workaround. Federation remotes that ship unminified are slow to load and leak internal structure. This is a production blocker — not for today, because there's no live shell host yet, but it needs a fix before the shell host goes live in any environment that matters. Reproduce locally first, document the options, then open the fix PR.

**3. TripPlanner PR #11 (`GET /api/tools`).** Once this merges, three apps expose the capability manifest. At that point the first ShellAgent tool-discovery query is worth writing — a single function that hits all registered remotes and returns a merged capability map. Even hardcoded endpoint URLs are fine for the first iteration; the goal is validating ADR-0007's contract shape under real multi-app conditions.

Parallel to all three: the cross-repo ADR index should be created this week. It's low effort and makes everything else more legible.

---

*Generated by [daily-logger](https://github.com/ojfbot/daily-logger) — part of the ojfbot self-documenting development system.*
